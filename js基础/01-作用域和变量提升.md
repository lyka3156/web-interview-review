## 作用域和变量提升

### 1. 概念

作用域:

1. 作用域就是一个变量可以被访问的范围，也就是说，你定义了一个变量，在哪里可以访问它，哪里就是它的作用域。
2. 在全局可以访问就是全局作用域，在函数体内可以访问就是函数作用域，ES6 引入了快级作用域。

变量提升:

1. 函数和变量的声明都被提升到函数的最顶部，也就是说变量可以在使用后声明，换句话说就是可以先声明再使用

### 2. 用途

作用域常用在闭包中，闭包可以在一个内层函数中访问到其外层函数的作用域。

### 3. 原理

1. 作用域的核心原理:在 JavaScript 中，所有绑定的声明 会在控制流到达它们出现的作用域时被初始化；这里的作用域其实就是所谓的执行上下文（Execution Context），每个执行上下文分为内存分配（Memory Creation Phase）与执行（Execution）这两个阶段。在执行上下文的内存分配阶段会进行变量创建，即开始进入了变量的生命周期；变量的生命周期包含了声明（Declaration phase）、初始化（Initialization phase）与赋值（Assignment phase）过程这三个过程。

2. 变量提升的核心原理：传统的 var 关键字声明的变量允许在声明之前使用，此时该变量被赋值为 undefined；而函数作用域中声明的函数同样可以在声明前使用，其函数体也被提升到了头部。这种特性表现也就是所谓的提升（Hoisting）；虽然在 ES6 中以 let 与 const 关键字声明的变量同样会在作用域头部被初始化，不过这些变量仅允许在实际声明之后使用。在作用域头部与变量实际声明处之间的区域就称为所谓的暂时死域（Temporal Dead Zone），TDZ 能够避免传统的提升引发的潜在问题。另一方面，由于 ES6 引入了块级作用域，在块级作用域中声明的函数会被提升到该作用域头部，即允许在实际声明前使用；而在部分实现中该函数同时被提升到了所处函数作用域的头部，不过此时被赋值为 undefined。

### 4. 优缺点

闭包的
优点：

1. 设计私有的方法和变量。
2. 可以重复使用变量，并且不会造成变量污染。

缺点

1. 闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。
2. 如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。

变量提升：
优点：

1. 可以先使用再声明，针对 var；
2. 容错率比较高
3. 规范性比较高：针对的 let 或 const，必须先声明再使用

### 5. 扩展

#### 1. 作用域的分类

1. 全局作用域：当我们在浏览器控制台或者 Node.js 交互终端中开始编写 JavaScript 时，即进入了所谓的全局作用域；定义在全局作用域中的变量能够被任意的其他作用域中访问。（看示例 1）
2. 函数作用域：定义在某个函数内的变量即从属于当前函数作用域，在每次函数调用中都会创建出新的上下文；换言之，我们可以在不同的函数中定义同名变量，这些变量会被绑定到各自的函数作用域中；函数作用域的缺陷在于粒度过大，在使用闭包或者其他特性时导致异常的变量传递。（看示例 2）
3. 块级作用域：let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。（示例 3）

#### 2. 作用域链的前提知识点——自由变量

```js
var a = 100;
function fn() {
	var b = 200;
	console.log(a); // 这里的a在这里就是一个自由变量
	console.log(b);
}
fn();
```

如上代码中，console.log(a)要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找。

#### 3. 作用域链：

概念：当在一个函数内部声明另一一个函数时，就会出现函数嵌套的效果。当函数嵌套时，内层函数只能在外层函数作用域内执行，在内层函数执行的过程中，若需要引人某个变量，首先会在当前作用域中寻找，若未找到，则继续向上一- 层级的作用域中寻找，直到全局作用域。我们称这种链式的查询关系为作用域链。

#### 4. 作用域访问优先级：

变量提升 < 形参赋值 < 函数提升 < 变量赋值

```js
function fn(a) {
	console.log(c); // 1. 变量提升
	var c;
	console.log(a); // 输出[Function: a]
	a = 1; // 4. 变量赋值
	console.log(a); // 输出1
	function a() {
		// 3. 函数提升
		return 2;
	}
}
fn(3); // 2. 函数传参
```
